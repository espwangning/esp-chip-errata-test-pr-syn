[CPU] 写 LP SRAM 时指令执行乱序导致死锁
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. only:: esp32c6

   .. tags::
      
      v0.0, v0.1

.. only:: esp32h2

   .. tags::

      v0.0, v0.1

描述
^^^^

HP CPU 从 LP SRAM 取指运行时，若依次执行的两条指令 A 和 B 满足以下模式：

- 指令 A 是写内存指令，例如 **sw**/**sh**/**sb**
- 指令 B 是只访问指令总线的指令，例如 **nop**/**jal**/**jalr**/**lui**/**auipc**
- 指令 B 的地址未四字节对齐

则仅当 B 指令执行完后，A 指令写的数据才会真实写入内存。这种情况可能带来风险：若在 A 指令写内存之后，B 指令存在无限循环的情况，则 A 指令的写操作永远无法完成。

变通方法
^^^^^^^^

遇到该问题或汇编代码出现上述模式时，

- 在指令 A 与无限循环间添加 **fence** 指令，在 ESP-IDF 中可使用 *rv_utils_memory_barrier* 接口。
- 使用 **wfi** 指令替代无限循环，在 ESP-IDF 中可使用 *rv_utils_wait_for_intr* 接口。
- 在编译 LP SRAM 中的程序时，禁用 RV32C（压缩）指令扩展，以避免产生非四字节对齐的指令。

解决方案
^^^^^^^^

.. only:: esp32c6

   已在芯片版本 :bdg-success:`v0.2` 中修复。

.. only:: esp32h2

   已在芯片版本 :bdg-success:`v1.2` 中修复。
